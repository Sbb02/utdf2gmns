[
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "geocoder",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "geocoder",
        "description": "geocoder",
        "detail": "geocoder",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "func_running_time",
        "importPath": "utils_lib.utility_lib",
        "description": "utils_lib.utility_lib",
        "isExtraImport": true,
        "detail": "utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "calculate_point2point_distance_in_km",
        "importPath": "utils_lib.utility_lib",
        "description": "utils_lib.utility_lib",
        "isExtraImport": true,
        "detail": "utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "check_required_files_exist",
        "importPath": "utils_lib.utility_lib",
        "description": "utils_lib.utility_lib",
        "isExtraImport": true,
        "detail": "utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "func_running_time",
        "importPath": "utils_lib.utility_lib",
        "description": "utils_lib.utility_lib",
        "isExtraImport": true,
        "detail": "utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "get_file_names_from_folder_by_type",
        "importPath": "utils_lib.utility_lib",
        "description": "utils_lib.utility_lib",
        "isExtraImport": true,
        "detail": "utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "path2linux",
        "importPath": "utils_lib.utility_lib",
        "description": "utils_lib.utility_lib",
        "isExtraImport": true,
        "detail": "utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "validate_filename",
        "importPath": "utils_lib.utility_lib",
        "description": "utils_lib.utility_lib",
        "isExtraImport": true,
        "detail": "utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "sin",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "cos",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "atan2",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "radians",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "generate_coordinates_from_intersection",
        "importPath": "func_lib.geocoding_intersection",
        "description": "func_lib.geocoding_intersection",
        "isExtraImport": true,
        "detail": "func_lib.geocoding_intersection",
        "documentation": {}
    },
    {
        "label": "match_intersection_node",
        "importPath": "func_lib.match_node_intersection_movement_utdf",
        "description": "func_lib.match_node_intersection_movement_utdf",
        "isExtraImport": true,
        "detail": "func_lib.match_node_intersection_movement_utdf",
        "documentation": {}
    },
    {
        "label": "match_movement_and_intersection_node",
        "importPath": "func_lib.match_node_intersection_movement_utdf",
        "description": "func_lib.match_node_intersection_movement_utdf",
        "isExtraImport": true,
        "detail": "func_lib.match_node_intersection_movement_utdf",
        "documentation": {}
    },
    {
        "label": "match_movement_utdf_lane",
        "importPath": "func_lib.match_node_intersection_movement_utdf",
        "description": "func_lib.match_node_intersection_movement_utdf",
        "isExtraImport": true,
        "detail": "func_lib.match_node_intersection_movement_utdf",
        "documentation": {}
    },
    {
        "label": "match_movement_utdf_phase_timeplans",
        "importPath": "func_lib.match_node_intersection_movement_utdf",
        "description": "func_lib.match_node_intersection_movement_utdf",
        "isExtraImport": true,
        "detail": "func_lib.match_node_intersection_movement_utdf",
        "documentation": {}
    },
    {
        "label": "generate_intersection_data_from_utdf",
        "importPath": "func_lib.read_utdf",
        "description": "func_lib.read_utdf",
        "isExtraImport": true,
        "detail": "func_lib.read_utdf",
        "documentation": {}
    },
    {
        "label": "read_UTDF_file",
        "importPath": "func_lib.read_utdf",
        "description": "func_lib.read_utdf",
        "isExtraImport": true,
        "detail": "func_lib.read_utdf",
        "documentation": {}
    },
    {
        "label": "required_files",
        "importPath": "utils_lib.package_settings",
        "description": "utils_lib.package_settings",
        "isExtraImport": true,
        "detail": "utils_lib.package_settings",
        "documentation": {}
    },
    {
        "label": "required_files_sub",
        "importPath": "utils_lib.package_settings",
        "description": "utils_lib.package_settings",
        "isExtraImport": true,
        "detail": "utils_lib.package_settings",
        "documentation": {}
    },
    {
        "label": "geocoder_geocoding_from_address",
        "kind": 2,
        "importPath": "utdf2gmns.func_lib.geocoding_intersection",
        "description": "utdf2gmns.func_lib.geocoding_intersection",
        "peekOfCode": "def geocoder_geocoding_from_address(address: str) -> tuple:\n    # initialize geocoder arcgis client\n    location_instance = geocoder.arcgis(address).geojson\n    # get the location\n    try:\n        location_lng_lat = (location_instance[\"features\"][0][\"geometry\"][\"coordinates\"])\n    except Exception:\n        location_lng_lat = [0, 0]\n    return location_lng_lat\n@func_running_time",
        "detail": "utdf2gmns.func_lib.geocoding_intersection",
        "documentation": {}
    },
    {
        "label": "generate_coordinates_from_intersection",
        "kind": 2,
        "importPath": "utdf2gmns.func_lib.geocoding_intersection",
        "description": "utdf2gmns.func_lib.geocoding_intersection",
        "peekOfCode": "def generate_coordinates_from_intersection(df_intersection: pd.DataFrame, distance_threshold=0.01) -> pd.DataFrame:\n    # distance_threshold is the threshold to determine whether the intersection is able to geocode, using km as unit\n    df = df_intersection\n    # check required columns exist in the dataframe\n    if not {\"intersection_name\", \"city_name\"}.issubset(set(df.columns)):\n        raise Exception(\n            \"intersection_name and city_name are not in the dataframe, please check the input file.\")\n    # Create one column named \"reversed_intersection_name\"\n    for i in range(len(df)):\n        if \"&\" in df.loc[i, \"intersection_name\"]:",
        "detail": "utdf2gmns.func_lib.geocoding_intersection",
        "documentation": {}
    },
    {
        "label": "find_shortest_distance_node",
        "kind": 2,
        "importPath": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "description": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "peekOfCode": "def find_shortest_distance_node(point: tuple, node_df: pd.DataFrame, max_distance_threshold: float = 0.1) -> tuple:\n    \"\"\" point: a tuple of (longitude, latitude),\n        node_df: a dataframe of node information,\n        max_distance_threshold (km): the maximum distance threshold to find the nearest node\n    \"\"\"\n    # get node longitude and latitude from node_df\n    node_location_list = [(node_df.loc[i, \"x_coord\"], node_df.loc[i, \"y_coord\"]) for i in range(node_df.shape[0])]\n    # calculate the distance between point and each node\n    point_to_node_distance_list = [calculate_point2point_distance_in_km(point, node_location) for node_location in node_location_list]\n    # find the minimum distance",
        "detail": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "documentation": {}
    },
    {
        "label": "match_intersection_node",
        "kind": 2,
        "importPath": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "description": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "peekOfCode": "def match_intersection_node(df_intersection_geo: pd.DataFrame, df_node: pd.DataFrame) -> pd.DataFrame:\n    # get valid node data with ctrl_type = signal\n    df_node_signal = df_node[df_node[\"ctrl_type\"] == \"signal\"].reset_index(drop=True)\n    #  mach intersection_geo with node\n    col_intersection_geo = list(df_intersection_geo.columns)\n    col_node = list(df_node_signal.columns)\n    intersection_node_list = []\n    for i in range(len(df_intersection_geo)):\n        intersection_value = list(df_intersection_geo.loc[i, :])\n        intersection_lnglat = (",
        "detail": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "documentation": {}
    },
    {
        "label": "match_movement_and_intersection_node",
        "kind": 2,
        "importPath": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "description": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "peekOfCode": "def match_movement_and_intersection_node(df_movement: pd.DataFrame, df_intersection_node: pd.DataFrame) -> pd.DataFrame:\n    # match movement with intersection_node by osm_node_id\n    col_movement = list(df_movement.columns)\n    col_intersection_node = list(df_intersection_node.columns)\n    movement_intersection_list = []\n    for k in range(len(df_movement)):\n        # get the osm_node_id of the movement\n        movement_osm_node_id = df_movement.loc[k, \"osm_node_id\"]\n        # get filter the intersection_node by osm_node_id\n        matched_intersection_node_list = list(",
        "detail": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "documentation": {}
    },
    {
        "label": "match_movement_utdf_lane",
        "kind": 2,
        "importPath": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "description": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "peekOfCode": "def match_movement_utdf_lane(df_movement_intersection: pd.DataFrame, utdf_dict_data: dict) -> pd.DataFrame:\n    # Add Synchro/utdf data to movement_intersection_node\n    df_utdf_lanes = utdf_dict_data.get(\"Lanes\")\n    intersection_id_list = [value for value in list(\n        df_movement_intersection[\"synchro_INTID\"].unique()) if value is not None]\n    # get movement_intersection dataframe with and without id list\n    df_with_id = df_movement_intersection[df_movement_intersection[\"synchro_INTID\"].isin(\n        intersection_id_list)]\n    df_without_id = df_movement_intersection[~df_movement_intersection[\"synchro_INTID\"].isin(\n        intersection_id_list)]",
        "detail": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "documentation": {}
    },
    {
        "label": "match_movement_utdf_phase_timeplans",
        "kind": 2,
        "importPath": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "description": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "peekOfCode": "def match_movement_utdf_phase_timeplans(df_movement_utdf_lane: pd.DataFrame, utdf_dict_data: dict) -> pd.DataFrame:\n    df_utdf_phase_timeplans = utdf_dict_data.get(\"phase_timeplans\")\n    return pd.merge(df_movement_utdf_lane, df_utdf_phase_timeplans, left_on=\"synchro_INTID\", right_on=\"INTID\", how=\"left\")",
        "detail": "utdf2gmns.func_lib.match_node_intersection_movement_utdf",
        "documentation": {}
    },
    {
        "label": "read_UTDF_file",
        "kind": 2,
        "importPath": "utdf2gmns.func_lib.read_utdf",
        "description": "utdf2gmns.func_lib.read_utdf",
        "peekOfCode": "def read_UTDF_file(path_utdf: str) -> dict:\n    \"\"\" read UTDF file and split data into different categories \"\"\"\n    # read the utdf.csv file\n    with open(path_utdf, encoding='utf-8') as f:\n        lines = f.readlines()\n    # find the start index of each category, the index is the row contain column names\n    categorical_data_beginning_index_dict = {}\n    for i in range(len(lines)):\n        if \"Network\" in lines[i] and utdf_categories[\"Network\"] in lines[i + 1]:\n            categorical_data_beginning_index_dict[i+2] = \"Network\"",
        "detail": "utdf2gmns.func_lib.read_utdf",
        "documentation": {}
    },
    {
        "label": "generate_intersection_data_from_utdf",
        "kind": 2,
        "importPath": "utdf2gmns.func_lib.read_utdf",
        "description": "utdf2gmns.func_lib.read_utdf",
        "peekOfCode": "def generate_intersection_data_from_utdf(utdf_dict_data: dict, city_name: str) -> pd.DataFrame:\n    # Get link data from utdf\n    df_link = utdf_dict_data[\"Links\"]\n    # update columns name\n    df_link.columns = [i.replace(\"\\n\", \"\") if \"\\n\" in i else i for i in df_link.columns.tolist()]\n    # remove unnecessary rows / invalid rows with NaN\n    df_link = df_link[df_link[\"INTID\"].notna()]\n    # clean the data / remove '\\n' in the end of column SW\n    # df_link = df_link.rename(columns={\"SW\\n\": \"SW\"})\n    # df_link[\"SW\"] = df_link[\"SW\"].map(lambda x: x.replace(\"\\n\", \"\"))",
        "detail": "utdf2gmns.func_lib.read_utdf",
        "documentation": {}
    },
    {
        "label": "spanning_phase_timeplans_data",
        "kind": 2,
        "importPath": "utdf2gmns.func_lib.read_utdf",
        "description": "utdf2gmns.func_lib.read_utdf",
        "peekOfCode": "def spanning_phase_timeplans_data(utdf_dict_data: dict, isSimpleCol: bool = True) -> pd.DataFrame:\n    df_phase = utdf_dict_data.get(\"Phases\")\n    df_timeplans = utdf_dict_data.get(\"Timeplans\")\n    # get unique intersection id\n    intersection_id = df_phase[\"INTID\"].unique().tolist()\n    final_spanned_list = []\n    for INTID in intersection_id:\n        # get utdf_phase dataframe by id\n        df_phase_single_id = df_phase[df_phase[\"INTID\"] == INTID].reset_index(drop=True)\n        df_timeplans_single_id = df_timeplans[df_timeplans[\"INTID\"] == INTID].reset_index(drop=True)",
        "detail": "utdf2gmns.func_lib.read_utdf",
        "documentation": {}
    },
    {
        "label": "pd.options.mode.chained_assignment",
        "kind": 5,
        "importPath": "utdf2gmns.func_lib.read_utdf",
        "description": "utdf2gmns.func_lib.read_utdf",
        "peekOfCode": "pd.options.mode.chained_assignment = None  # default='warn'\n@func_running_time\ndef read_UTDF_file(path_utdf: str) -> dict:\n    \"\"\" read UTDF file and split data into different categories \"\"\"\n    # read the utdf.csv file\n    with open(path_utdf, encoding='utf-8') as f:\n        lines = f.readlines()\n    # find the start index of each category, the index is the row contain column names\n    categorical_data_beginning_index_dict = {}\n    for i in range(len(lines)):",
        "detail": "utdf2gmns.func_lib.read_utdf",
        "documentation": {}
    },
    {
        "label": "required_files",
        "kind": 5,
        "importPath": "utdf2gmns.utils_lib.package_settings",
        "description": "utdf2gmns.utils_lib.package_settings",
        "peekOfCode": "required_files = [\"UTDF.csv\"]\nrequired_files_sub = [\"node.csv\", \"movement.csv\"]\nutdf_categories = {\n    \"Network\": \"Network Settings\",\n    \"Nodes\": \"Node Data\",\n    \"Links\": \"Link Data\",\n    \"Lanes\": \"Lane Group Data\",\n    \"Timeplans\": \"Timing Plan Settings\",\n    \"Phases\": \"Phasing Data\"}\nlink_column_names = {",
        "detail": "utdf2gmns.utils_lib.package_settings",
        "documentation": {}
    },
    {
        "label": "required_files_sub",
        "kind": 5,
        "importPath": "utdf2gmns.utils_lib.package_settings",
        "description": "utdf2gmns.utils_lib.package_settings",
        "peekOfCode": "required_files_sub = [\"node.csv\", \"movement.csv\"]\nutdf_categories = {\n    \"Network\": \"Network Settings\",\n    \"Nodes\": \"Node Data\",\n    \"Links\": \"Link Data\",\n    \"Lanes\": \"Lane Group Data\",\n    \"Timeplans\": \"Timing Plan Settings\",\n    \"Phases\": \"Phasing Data\"}\nlink_column_names = {\n    1: 'RECORDNAME',",
        "detail": "utdf2gmns.utils_lib.package_settings",
        "documentation": {}
    },
    {
        "label": "utdf_categories",
        "kind": 5,
        "importPath": "utdf2gmns.utils_lib.package_settings",
        "description": "utdf2gmns.utils_lib.package_settings",
        "peekOfCode": "utdf_categories = {\n    \"Network\": \"Network Settings\",\n    \"Nodes\": \"Node Data\",\n    \"Links\": \"Link Data\",\n    \"Lanes\": \"Lane Group Data\",\n    \"Timeplans\": \"Timing Plan Settings\",\n    \"Phases\": \"Phasing Data\"}\nlink_column_names = {\n    1: 'RECORDNAME',\n    2: 'INTID',",
        "detail": "utdf2gmns.utils_lib.package_settings",
        "documentation": {}
    },
    {
        "label": "link_column_names",
        "kind": 5,
        "importPath": "utdf2gmns.utils_lib.package_settings",
        "description": "utdf2gmns.utils_lib.package_settings",
        "peekOfCode": "link_column_names = {\n    1: 'RECORDNAME',\n    2: 'INTID',\n    3: 'NB',\n    4: 'SB',\n    5: \"EB\",\n    6: \"WB\",\n    7: \"NE\",\n    8: \"NW\",\n    9: \"SE\",",
        "detail": "utdf2gmns.utils_lib.package_settings",
        "documentation": {}
    },
    {
        "label": "utdf_setting",
        "kind": 5,
        "importPath": "utdf2gmns.utils_lib.package_settings",
        "description": "utdf2gmns.utils_lib.package_settings",
        "peekOfCode": "utdf_setting = {\"city_name\": \" Bullhead, AZ\"}\nlane_column_names = {1: 'Up_Node',\n                     2: 'Dest_Node',\n                     3: 'Lanes',\n                     4: 'Shared',\n                     5: 'Width',\n                     6: 'Storage',\n                     7: 'Taper',\n                     8: 'StLanes',\n                     9: 'Grade',",
        "detail": "utdf2gmns.utils_lib.package_settings",
        "documentation": {}
    },
    {
        "label": "lane_column_names",
        "kind": 5,
        "importPath": "utdf2gmns.utils_lib.package_settings",
        "description": "utdf2gmns.utils_lib.package_settings",
        "peekOfCode": "lane_column_names = {1: 'Up_Node',\n                     2: 'Dest_Node',\n                     3: 'Lanes',\n                     4: 'Shared',\n                     5: 'Width',\n                     6: 'Storage',\n                     7: 'Taper',\n                     8: 'StLanes',\n                     9: 'Grade',\n                     10: 'Speed',",
        "detail": "utdf2gmns.utils_lib.package_settings",
        "documentation": {}
    },
    {
        "label": "func_running_time",
        "kind": 2,
        "importPath": "utdf2gmns.utils_lib.utility_lib",
        "description": "utdf2gmns.utils_lib.utility_lib",
        "peekOfCode": "def func_running_time(func):\n    def inner(*args, **kwargs):\n        print(f'INFO Begin to run function: {func.__name__} …')\n        time_start = datetime.datetime.now()\n        res = func(*args, **kwargs)\n        time_diff = datetime.datetime.now() - time_start\n        print(\n            f'INFO Finished running function: {func.__name__}, total: {time_diff.seconds}s')\n        print()\n        return res",
        "detail": "utdf2gmns.utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "path2linux",
        "kind": 2,
        "importPath": "utdf2gmns.utils_lib.utility_lib",
        "description": "utdf2gmns.utils_lib.utility_lib",
        "peekOfCode": "def path2linux(path: Union[str, Path]) -> str:\n    \"\"\"Convert a path to a linux path, linux path can run in windows, linux and mac\"\"\"\n    try:\n        return path.replace(\"\\\\\", \"/\")\n    except Exception:\n        return str(path).replace(\"\\\\\", \"/\")\ndef get_file_names_from_folder_by_type(dir_name: str, file_type: str = \"txt\",\n                                       isTraverseSubdirectory: bool = False) -> list:\n    if isTraverseSubdirectory:\n        files_list = []",
        "detail": "utdf2gmns.utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "get_file_names_from_folder_by_type",
        "kind": 2,
        "importPath": "utdf2gmns.utils_lib.utility_lib",
        "description": "utdf2gmns.utils_lib.utility_lib",
        "peekOfCode": "def get_file_names_from_folder_by_type(dir_name: str, file_type: str = \"txt\",\n                                       isTraverseSubdirectory: bool = False) -> list:\n    if isTraverseSubdirectory:\n        files_list = []\n        for root, dirs, files in os.walk(dir_name):\n            files_list.extend([os.path.join(root, file) for file in files])\n        return [path2linux(file) for file in files_list if file.split(\".\")[-1] == file_type]\n    # files in the first layer of the folder\n    return [path2linux(os.path.join(dir_name, file)) for file in os.listdir(dir_name) if file.split(\".\")[-1] == file_type]\ndef check_required_files_exist(required_files: list, dir_files: list) -> bool:",
        "detail": "utdf2gmns.utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "check_required_files_exist",
        "kind": 2,
        "importPath": "utdf2gmns.utils_lib.utility_lib",
        "description": "utdf2gmns.utils_lib.utility_lib",
        "peekOfCode": "def check_required_files_exist(required_files: list, dir_files: list) -> bool:\n    # format the required file name to standard linux path\n    required_files = [path2linux(os.path.abspath(filename)) for filename in required_files]\n    required_files_short = [filename.split(\"/\")[-1] for filename in required_files]\n    dir_files_short = [filename.split(\"/\")[-1] for filename in dir_files]\n    # mask have the same length as required_files\n    mask = [file in dir_files_short for file in required_files_short]\n    if all(mask):\n        return True\n    print(f\"Error: Required files are not satisfied, \\",
        "detail": "utdf2gmns.utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "validate_filename",
        "kind": 2,
        "importPath": "utdf2gmns.utils_lib.utility_lib",
        "description": "utdf2gmns.utils_lib.utility_lib",
        "peekOfCode": "def validate_filename(path_filename: str, ) -> str:\n    \"\"\"if the file name exist in path,then create new file name with _1, _1_1, ...\"\"\"\n    filename_abspath = path2linux(os.path.abspath(path_filename))\n    file_suffix = filename_abspath.split(\".\")[-1]\n    file_without_suffix = filename_abspath[:-len(file_suffix) - 1]\n    if os.path.exists(filename_abspath):\n        filename_update = f\"{file_without_suffix}_1.{file_suffix}\"\n        return validate_filename(filename_update)\n    return filename_abspath\ndef calculate_point2point_distance_in_km(point1: tuple, point2: tuple) -> float:",
        "detail": "utdf2gmns.utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "calculate_point2point_distance_in_km",
        "kind": 2,
        "importPath": "utdf2gmns.utils_lib.utility_lib",
        "description": "utdf2gmns.utils_lib.utility_lib",
        "peekOfCode": "def calculate_point2point_distance_in_km(point1: tuple, point2: tuple) -> float:\n    \"\"\" point1 and point2: a tuple of (longitude, latitude) \"\"\"\n    # approximate radius of earth in km\n    R = 6373.0\n    lat1 = radians(point1[1])\n    lon1 = radians(point1[0])\n    lat2 = radians(point2[1])\n    lon2 = radians(point2[0])\n    lon_diff = lon2 - lon1\n    lat_diff = lat2 - lat1",
        "detail": "utdf2gmns.utils_lib.utility_lib",
        "documentation": {}
    },
    {
        "label": "generate_utdf_dict_of_dataframes",
        "kind": 2,
        "importPath": "utdf2gmns.utdf2gmns",
        "description": "utdf2gmns.utdf2gmns",
        "peekOfCode": "def generate_utdf_dict_of_dataframes(utdf_filename: str, city_name: str) ->dict:\n    # read single UTDF file and produce data conversion and store data into a dictionary\n    # read UTDF file and create dataframes of utdf_geo and utdf_lane\n    utdf_dict_data = read_UTDF_file(utdf_filename)\n    df_utdf_intersection = generate_intersection_data_from_utdf(utdf_dict_data, city_name)\n    # geocoding utdf_intersection\n    df_utdf_geo = generate_coordinates_from_intersection(df_utdf_intersection)\n    # store utdf_geo and utdf_lane into utdf_dict_data\n    utdf_dict_data[\"utdf_geo\"] = df_utdf_geo\n    # store object into pickle file",
        "detail": "utdf2gmns.utdf2gmns",
        "documentation": {}
    },
    {
        "label": "generate_movement_utdf",
        "kind": 2,
        "importPath": "utdf2gmns.utdf2gmns",
        "description": "utdf2gmns.utdf2gmns",
        "peekOfCode": "def generate_movement_utdf(input_dir: list, city_name: list, output_dir: str = \"\", isSave2csv: bool = True) -> list[pd.DataFrame]:\n    # check if required files exist in the input directory\n    files_from_directory = get_file_names_from_folder_by_type(input_dir, file_type=\"csv\")\n    # if not required, raise an exception\n    isRequired = check_required_files_exist(required_files, files_from_directory)\n    isRequired_sub = check_required_files_exist(required_files_sub, files_from_directory)\n    # required fils are not found, raise an exception\n    if not isRequired:\n        raise Exception(f\"Required files {required_files} are not found!\")\n    # read UTDF file and create dataframes of utdf_intersection and utdf_lane",
        "detail": "utdf2gmns.utdf2gmns",
        "documentation": {}
    },
    {
        "label": "pd.options.mode.chained_assignment",
        "kind": 5,
        "importPath": "utdf2gmns.utdf2gmns",
        "description": "utdf2gmns.utdf2gmns",
        "peekOfCode": "pd.options.mode.chained_assignment = None  # default='warn'\n@func_running_time\ndef generate_utdf_dict_of_dataframes(utdf_filename: str, city_name: str) ->dict:\n    # read single UTDF file and produce data conversion and store data into a dictionary\n    # read UTDF file and create dataframes of utdf_geo and utdf_lane\n    utdf_dict_data = read_UTDF_file(utdf_filename)\n    df_utdf_intersection = generate_intersection_data_from_utdf(utdf_dict_data, city_name)\n    # geocoding utdf_intersection\n    df_utdf_geo = generate_coordinates_from_intersection(df_utdf_intersection)\n    # store utdf_geo and utdf_lane into utdf_dict_data",
        "detail": "utdf2gmns.utdf2gmns",
        "documentation": {}
    }
]